# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.


import os.path

from taskgraph.transforms.base import TransformSequence

transforms = TransformSequence()


@transforms.add
def add_beetmover_worker_config(config, tasks):
    for task in tasks:
        app_name = "vpn"
        worker_type = task["worker-type"]
        # is_relpro = (
        #     config.params["level"] == "3"
        #     and config.params["tasks_for"] in task["run-on-tasks-for"]
        # )
        # bucket = "release" if is_relpro else "dep"
        bucket = "dep"
        build_id = config.params["moz_build_date"]
        build_type = task["attributes"]["build-type"]
        candidates_path = os.path.join(
            "pub",
            app_name,
            "candidates",
            "addons",
            build_id,
        )
        latest_path = os.path.join(
            "pub",
            app_name,
            "candidates",
            "addons",
            "latest",  # latest candidates? or is this just for releases?
        )
        destination_paths = [candidates_path, latest_path]
        # archive_url = (
        #     "https://ftp.mozilla.org/" if is_relpro else "https://ftp.stage.mozaws.net/"
        # )
        archive_url = "https://ftp.stage.mozaws.net/"
        task_description = f"This {worker_type} task will upload {app_name} addons release candidates to {archive_url}{candidates_path}/"
        # the beetmover script behavior should override latest?
        branch = config.params["head_ref"]

        # could use the manifest files so beetmover knows what it's supposed to beetmove?
        # A: the manifest file is generated by a python script, so no?

        release_artifacts = []
        release_artifacts.append(
            {
                "type": "file",
                "name": f"public/build/addons/manifest.json",
                "path": f"/builds/worker/artifacts/addons/manifest.json",
            }
        )
        # TODO: add support for .sig file ext. in beetmoverscript
        # https://github.com/mozilla-releng/scriptworker-scripts/blob/ee4f0be08dbf144c582d6025a8db56e06db38658/beetmoverscript/src/beetmoverscript/constants.py#L1
        # release_artifacts.append(
        #     {
        #         "type": "file",
        #         "name": f"public/build/addons/manifest.json.sign",
        #         "path": f"/builds/worker/artifacts/addons/manifest.json.sig",
        #     }
        # )
        addons = set(os.listdir("addons"))
        addons.remove("examples")

        for addon in addons:
            release_artifacts.append(
                {
                    "type": "file",
                    "name": f"public/build/addons/{addon}.rcc",
                    "path": f"/builds/worker/artifacts/addons/{addon}.rcc",
                }
            )

        upstream_artifacts = []
        for dep in task["dependencies"]:
            upstream_artifacts.append(
                {
                    "taskId": {"task-reference": f"<{dep}>"},
                    "taskType": "build",  # TODO: update to signing once we have a signing-addons task
                    "paths": [
                        release_artifact["name"]
                        for release_artifact in release_artifacts
                    ],
                }
            )

        artifact_map = []
        for artifact in upstream_artifacts:
            artifact_map.append(
                {
                    "taskId": artifact["taskId"],
                    "paths": {
                        path: {
                            "destinations": [
                                os.path.join(
                                    destination_path,
                                    os.path.basename(path),
                                )
                                for destination_path in destination_paths
                            ]
                        }
                        for path in artifact["paths"]
                    },
                }
            )

        worker = {
            "upstream-artifacts": upstream_artifacts,
            "bucket": bucket,
            "action": "push-to-candidates",
            "release-properties": {
                "app-name": app_name,
                "app-version": "N/A",
                "branch": branch,
                "build-id": build_id,
                "platform": build_type,
            },
            "artifact-map": artifact_map,
        }
        task_def = {
            "name": task["name"],
            "description": task_description,
            "dependencies": task["dependencies"],
            "worker-type": worker_type,
            "worker": worker,
            "attributes": task["attributes"],
            "run-on-tasks-for": task["run-on-tasks-for"],
        }
        yield task_def
